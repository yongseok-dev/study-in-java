
# Chapter 07 상속 Inheritance

## 7.1 상속 개념

<aside>
💡 상속이란 무엇인가요?

상속은 부모가 자식에게 물려주는 행위

- 재사용을 통해서 중복을 줄이고 개발시간을 단축함
- 클래스의 수정을 최소화(부모 클래스를 수정하면 모든 자식 클래스에 수정효과 반영)
</aside>

## 7.2 클래스 상속

- 어떤 부모로 부터 상속 받을 것인지 자식이 부모를 선택
- `public class 자식클래스 **extends 부모클래스**{
}`
- 다중 상속을 허용하지 않는다. 단 하나의 부모 클래스만 와야함.

## 7.3 부모 생성자 호출

- 인스턴스화 : 부모 객체가 먼저 생성된 다음에 자식 객체가 생성됨
- `자식클래스 변수 = new 자식클래스();`
- 객체는 생성자를 호출해 인스턴스화 해야 생성된다.
    - 자식 클래스를 생성할 때, 무모 생성자가 자식 생성자 맨 첫 줄에서 `super()`에 의해 호출된다.
    - `public 자식클래스(…){
        **super()**;
    }`
    - 컴파일 과정에서 자동 추가 → 기본 생성자를 호출한다.
    - 매개변수 받는 생성자만 있다면, 개밯자가 직접 `super(매개값,…)` 형태로 직접 작성해야한다.

## 7.4 메소드 재정의

- 메소드 오버라이딩 ≠ 오버로드
    - 상속된 메소드를 자식클래스에서 재정의 하는 것.
    - 자식 메소드가 우선적으로 사용된다.
- 메소드 오버라이딩 규칙
    - 부모 메소드의 선언부(리턴타입, 메소드이름, 매개변수)와 동일 해아함
    - 접근 제한을 더 강하게 오버라이딩 할 수 없음
    - 새로운 예외를 throws할 수 없다
- `@Override`어노테이션: 컴파일 단계에서 정확히 오버라이딩이 되었는지 체크
- 부모 메소드 호출: `super.mathod()`
- 기본적으로 사용이 불가

## 7.5 final 클래스와 final 메소드

### final 클래스

- 더 이상 상속을 할 수 없는 클래스

### final 메소드

- 최종 메소드로 오버라이딩 할 수 는 메소드

## 7.6 protected 접근 제한자

- protected : 같은 패키지거나, 자식 객체!만 사용가능 상속 받는 곳에서 객체를 생성해서 사용할 수는 없음

## 7.7 타입 변환

### 자동 타입 변환

- `부모타입 변수 = 자식타입 객체;`
- 부모와 동일하게 취급될 수 있다.
- 부모 클래스에 선언된 필드와 메소드만 접근이 가능(교집합을 생각하면 됨)
- 자식 클래스에서 오버라이딩된 메소드가 있다면, 부모 메소드 대신 오버라이딩 된 메소드가 호출된다. → 다형성 구현

### 강제 타입 변환(Casting)

- 캐스팅 연산자로 강제 타입변환을 할 수 있다.
- 단, 부모타입으로 자동변환된 후 다시 자식타입으로 변환 할 때 사용가능
- 자식 타입에 선언된 필드와 메소드를 꼭 사용해야 한다면 강제 타입 변환을 해서 다시 자식타입으로 변환해야 한다.

## 7.8 다형성

- 사용방법은 동일하지만 실행 결과가 다양하게 나오는 성질
    - 자동타입변환 + 메소드 오버라이딩 → 다형성

### 필드 다형성

- 필드 타입은 동일, 대입되는 객체가 달라져서 실행 결과가 다양하게 나올 수 있는 것.

### 매개변수 다형성

- 메소드가 클래스 타입의 매개변수를 가지고 있을 경우 호출할 때 동일한 타입의 객체를 제공하는 것이 정석이지만, 자식객체를 제공할 수도 있음
- 자식객체가 재정의한 메서드를 실행하는 로직을 구현할 수 있음.

## 7.9 객체 타입 확인

- instanceof 연산자 사용 → type을 확인하는 연산자
    - `boolean result = 객체 instanceof 타입;`
    - 활용하여, 자식객체일 경우 다른 동작을 할 수 있도록 만들 수 있음.
        
        ```java
        if (객체 instanceof 자식타입) {
        			자식타입 객체 = (자식타입) 객체;
        }
        ```
        

## 7.10 추상 클래스

- 추상: 실체간에 공통되는 특성을 추출한 것
- 추상 클래스: 공통적인 필드나 메소드를 추출해서 선언한 클래스(실체 클래스의 부모 역할)
    - 공통적인 필드나 메소드를 물려 받을 수 있다.
    - 실체 클래스의 공통되는 필드와 메소드를 추출해서 만듬 →new 연산자를 사용해서 객체를 직접 생성할 수 없다.
    - 새로운 실체 클래스를 만들기 위한 부모클래스로만 사용됨.(extends 뒤에만 사용)
- 선언: `public abstract class 클래스명{}`
- 메소드 선언, 생성자 필요

### 추상 메소드와 재정의

- 메소드 선언부(리턴타입, 메소드면, 매개변수)만 동일 → 실행 내용은 자식마다 다르게
- 메소드를 추상형으로 선언할 수 있다.
    - `abstract 리턴타입 메소드명(매개변수,…);`
    - 추상 메소드는 자식 클래스의 공통 메소드만 정의함 → 실행내용 없음
    - 자식 클래스에서 반드시 재정의(오버라이딩) 해서 실행 내용을 채워야한다.

## 7.11 봉인된 클래스(15이상)

- fanal : 사용할 수 없음
- sealed : 상속가능한 자식 클래스를 지정
    - `public **sealed** class 봉인된클래스명 **permits** 상속받을클래스명,…`
- non-sealed : 상속 받은 자식 클래스 봉인해제
    - `public **non-sealed** class 상속받는클래스명 **extends** 봉인된클래스명`
