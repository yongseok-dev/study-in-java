# Chapter 06 `클래스`

## 6.1 객체 지향 프로그래밍(OOP, Object Oriented Programming)

<aside>
💡 객체 지향 프로그래밍이 무엇인가요?
부품에 해당하는 객체들을 먼저 만들고, 이 객체들을 하나씩 조립해서 완성된 프로그램을 만드는 기법

</aside>

<aside>
💡 객체란 무엇인가요?
객체 Object란 다른 것과 식별 가능한 것.
속성과 동작으로 구성되며 자바에서는 필드와 메소드로 표현된다.

</aside>

### 객체의 상호작용

- 객체들은 다른 객체와 서로 메소드를 통해 상호작용하면서 동작
    - 데이터 교환(매개변수와 리턴값)

### 객체간의 관계

- 집합관계
    - 완성품과 부품의 관계
- 사용관계
    - 다른 객체의 필드를 읽고 변경하거나 메소드를 호출하는 관계
- 상속관계
    - 부모와 자식관계

### 객체 지향 프로그래밍의 특징

- 캡슐화(Encapsulation)
    - 데이터(필드), 동작(메소드)을 하나로 묶고 실제 구현 내용을 외부에 감추는 것
    - 외부 객체는 내부 구조를 모르며 객체가 노출해서 제공하는 필드와 메소드만 이용
    - 접근제한자를 사용해 접근 대상을 한정
- 상속(Inheritance)
    - 부모객체는 자기가 가지고 있는 필드와 메소드를 자식객체에게 물려주어 자식객체가 사용할 수 있도록 함
        - 코드의 재사용성
        - 유지 보수 시간을 최소화
- 다형성(Polymorphisom)
    - 사용방법은 동일하지만 실행 결과가 다양하게 나오는 성질
    - 자동타입변환, 재정의 기술이 필요 → 상속과 인터페이스 구현 사용

## 6.2 객체와 클래스(Class)

<aside>
💡 클래스란 무엇인가요?
객체를 생성을 위해 사용하는 설계도

</aside>

- 인스턴스(Instance)
    - 클래스로부터 생성된 객체

## 6.3 클래스 선언

- 클래스 요소
    - 생성자: 어떻게 객체를 생성
    - 필드:객체가 가져야 할 데이터가 무엇인지
    - 메소드: 객체의 동작은 무엇인지
- 클래스 선언은 소스파일명과 동일하게 작성
    - 클래스명.java
        
        ```java
        // 클래스 선언
        public class 클래스명{
        }
        ```
        
- 하나의 소스파일에서 복수의 클래스를 선언 가능함
    - 컴파일 하면 바이트코드 파일(.class)가 클래스 선언 수 많큼 생긴다.
    - 소스파일과 동일한 클래스만 `public class`로 선언

## 6.4 객체 생성과 클래스 변수

- 인스턴스화: 클래스로 부터 객체를 생성
- `클래스 변수 = new 클래스()`: `new` 연산자는 객체를 생성시킨 후 객체의 주소를 리턴 변수에 대입
- 변수에 저장한 참조하는 메모리 주소 → 스택영역
- 객체 인스턴스 → 힙영역
- 클래스의 용도
    - 라이브러리 클래스: 실행할 수 없으며 다른 클래스에서 이용하는 클래스
    - 실행 클래스: main()메소드를 가지고 있는 실행가능 클래스

## 6.5 클래스의 구성 멤버

```java
public class ClassName{
	// 필드(Field) 선언 
	int fieldName; //객체의 데이터가 저장
	
	// 생성자(Constructor) 선언
	ClassName(){
		// 객체 생성 시 초기화 역할 담당
	}
	// 메소드(Method) 선언
	int methodName(){
		// 객체의 동작으로 호출시 실행하는 블록
	}
}
```

## 6.6 필드 선언과 사용

### 필드 선언

- 변수 선언과 동일 방법(단, 클래스 블록 내에서 선언)
    - 로컬변수: 생성자, 메소드 선언 블록 내에서 선언(외부에서 호출 불가)
- `타입 필드명 [ = 초기값];`
    - 타입: 기본타입, 참조타입(배열, 클래스, 인터페이스) 모두 가능
    - 필드명은 첫문자 소문자 캐멀 스타일
    - 초기값: 생략시 기본값으로 초기화

### 필드 사용

- 필드를 사용한다는 것은 인스턴스 내의 필드값을 읽고 변경하는 것
    - 클래스에서 필드를 선언했다고 해서 바로 사용할 수 있는 것은 아님
    - 객체를 생성 후 필드를 객체 내부 외부에서 사용 가능
        - 외부 접근시 참조 변수와 도트(`.`) 연산자 이용
- 

## 6.7 생성자 선언과 호출

- new 연산자
    - 객체를 생성
    - 생성자를 호출 → 객체 초기화
    - 인스턴스의 주소 리턴

### 기본생성자

- 클래스에 생성자가 없어 컴파일러가 바이트코드 파일에 자동으로 추가
- 클래스가 public이면 생성자도 public으로 붙여준다.

### 생성자 선언

```java
class 클래스{
	클래스(매개값,...){
		//객체의 초기화 코드
	}
}
```

- 메소드와 비슷하나 리턴타입이 없음
- 매개값을 생성자 블록 내부로 전달

### 필드 초기화

- 객체마다 동일한 값을 갖고 있다면 필드선언시 초기값 대입
- 객체마다 다른 값을 가진다면 생성자에서 필드를 초기화
    
    ```java
    //field
    	String nation="kor";
    	String name;
    	String ssn;
    	
    	//constructor
    	public Korean(String name, String ssn) {
    		this.name = name;
    		this.ssn = ssn;		
    	}
    ```
    
- `this.*`를 통해서 필드와 매개변수를 구분
- this는 현재 객체를 말함.

### 생성자 오버로딩

- 매개변수로 객체의 필드를 다양하게 초기화 하려면 생성자 오버로딩이 필요
- 매개변수를 달리하는 생성자를 여러 개 선언하는 것
    - 매개변수의 타입, 개수, 순서가 다르게 여러개의 생성자 선언
- 매개변수의 동일타입의 순서와 개수인 경우 오버로딩이 아님!(이름만 달라지는 경우 컴파일러가 알 수 없음)
- 매개변수와 타입과 개수의 생성자 결

### 다른 생성자 호출

- 생성자 오버로딩이 많아질 때 중복된 코드 발생
    - 다른 생성자 호출을 통해서 중복을 줄일 수 있다(구조 변경시 동일성 유지 유리)
    - `this(…)` → `this(매개변수,...)` : this 가 객체이기 때문에 본인 생성자를 부르게 됨
- 객체 내부에 생성자들이 들어가 있다고 보는게 적절함.
    - 한번 생성된 객체(인스턴스)의 생성자에는 접근이 제한된다.

## 6.8 메소드 선언과 호출

- 메소드 선언은 객체의 동작을 실행 블록으로 정의하는 것
- 객체간 상호작용하는 방법을 정의하는것
    
    ### 메소드 선언
    
    ```java
    //선언부
    리턴타입 메소드명(매개변수,...){
    	//실행블록: 실행코드를 작성하는 곳
    }
    ```
    
    - 리턴타입: 메소드가 리턴하는 값의 타입 표시
        - 리턴이 없는 경우 void 사용
    - 메소드명: 소문자 시작 캐멀케이스
    - 매개변수: 인자를 받기 위해 사용, 필요하지 않다면 생략 가능
    - 실행블록: 실행되는 부
    
    ### 메소드 호출
    
    - `타입 변수 = 객체변수명.메소드();`
    - 호출(콜): 메소드 블록을 실행하는 것 → 객체가 존재해야한다.
    - 외부 객체에서는 참조 변수와 도트 연산자를 이용해서 호출
    - 메소드가 매개변수를 가지고 있다면 매개변수의 타입과 수에 맞게 인자를 넘겨야한다.
    
    ### 가변길이 매개변수
    
    - 선언
        
        ```java
        int sum(int ... values){
        
        }
        ```
        
    - 호출
        
        ```java
        int resert = sum(1,2,3);
        int resert = sum(1,2,3,4,5);
        ```
        
    - 자동으로 배열 항목으로 변환되어 메소드에 사용됨(당연 동일한 타입만 받아짐)
    
    ### return문
    
    - 호출한 곳으로 돌아간다는 의미
    - `return` 문 이후의 실행문은 실행되지 않아 컴파일 에러(`Unreachable code`) 발생
        - 다만 분기식을 통해서 return 시에는 발생하지 않음.
    
    ### 메소드 오버로딩(Overloading)
    
    - 메소드 이름은 같되 매개변수의 타입, 개수, 순서가 다른 메소드
    - 다양한 인자를 처리하기 위함

## 6.9 인스턴스 멤버

- 필드와 메소드는 선언 방법에 따라 인스턴스 멤버와 정적 멤버로 분류
    - 인스턴스멤버: 객체에 소속된 멤버(객체 없이 사용불가)
    - 정적(static) 멤버: 클래스에 고정된 멤버(객체 없이도 사용가능)

### 인스턴스 멤버 선언 및 사용

```java
public class Car{
	//instance field
	int gas;

	//instanc method
	void setSpeed(int speed){...}
}
```

- 인스턴스멤버를 외부 클래스에서 사용하기 위해서는 객체를 먼저 새성하고 참조변수로 접근해서 사용
- 메소드는 코드의 덩어리로 객체마다 저장하면 중복저장으로 메모리 효율이 떨어짐
    - 메소드 코드는 메소드 영역에 둬 공유
    - 단, 객체 없이는 사용하지 못하도록 제한

### this 키워드

- 객체 내부에서 인스턴스 멤버에 접근하기 위해 this 사용

## 6.10 정적(static) 멤버

- 자바는 클래스로더 를 이용해 클래스를 메소드 영역에 저장하고 사용
- 정적 멤버란 메소드 영역의 클래스에 고정적으로 위치하는 멤버
    - 객체를 생성할 필요 없이 클래스를 통해 바로 사용이 가능

### 정적 멤버 선언

- 필드와 메소드 모두 정적 멤버가 될 수 있다.
- `static` 키워드 사용

```java
public class 클래스{
	// 정적 필드 선언
	static 타입 필드 [= 초기값];
	// 정적 메소드
	static 리턴타입 메소드(매개변수, ...){...}
}
```

- 객체마다 가지고 있을 필요성이 없는 공용적인 필드는 정적 필드로 선언하는 것이 좋다.

### 정적 멤버 사용

- 클래스가 메모리로 로딩 되면 정적 멤버를 바로 사용할 수 있는데, 클래스 이름과 도트 연산자로 접

### 정적 블록

- 필드 선언과 동시에 초기값을 주는 것이 일반적
- 복잡한 초기화시 정적 블록을 이용
    
    ```java
    static{
    	...
    }
    ```
    
- 정적 블록이 클래스 내부에 여러 개가 선언되어 있을 경우에는 선언된 순서 대로 실행
- 정적 필드는 생성자에서 초기화 작업을 하지 않는다.

### 인스턴스 멤버 사용 불가

- 정적 메소드와 정적 블록은 객체가 없어도 실행
    - 내부에 인스턴스 필드나 인스턴스 메소드 사용 불가
    - 객체 자신의 참조인 `this` 사용불가
- 정적 메소드, 정적 블록에서 인스턴스 멤버를 사용하고 싶다면 객체를 먼저 생성하고 참조변수로 접

## 6.11 final 필드와 상수

- final 필드 상수를 선언해서 사용
    - 값을 변경하는 것을 막고 읽기만 허용
    
    ### final 필드 선언
    
    - final 필드는 초기값이 저장되면 이것이 최종적인 값이 되어서 프로그램 실행 도중에 수정할 수 없게 된다.
    - `final 타입 필드 [= 초기값];`
        - 필드 선언시 초기값 대입, 생성자에서 초기값 대입
    - final 필드를 그대로 남겨두면 컴파일 에러 발생
    
    ### 상수선언
    
    - 상수: 불변의 값
        - `static final 타입 상수 [= 초기값];`
            - 선언시 초기화하는게 일반적
            - 복잡한 초기화는 정적 블록에서  초기화 하기도 함
                
                ```java
                static final 타입 상수;
                static {
                	상수 = 초기값;
                }
                ```
                
    - 상수명: 대문자 작성, 단어 사이 언더바`_`
    - 상수는 정적 필드 → 클래스로 접근해서 읽을 수 있다. `클래스명.상수`
    - 

## 6.12 패키지

- 자바의 패키지는 클래스의 일부분이며, 클래스를 식별하는 용도.
    - 추가적으로 디렉토리의미
- 패키지는 상위 패키지와 하위 패키지를 도트로 구분

### 패키지 선언

- 컴파일 하는 과정에서 자동으로 생성
- 클래스의 패키지 선언을 보고 디렉토리를 자동으로 생성
- 항상 소스파일 최상단에 위치
    - 패키지 선언이 없다면 이클립스는 클래스를 default package에  포함
- 패키지 이름은 모두 소문자로 작성
    - 중복되지 않도록 작성하고
    - 회사도메인 이름의 역순으로 적성하고, 마지막에 프로젝트 이름을 붙임

### import문

- 다른 패키지에 있는 클래스를 사용하려면 import문을 이용해서 어떤 패키지의 클래스를 사용하는지 명시
- `import com.hankook.*;` *는 다수의 클래스를 사용하는 경우 붙인다.
    - 하위 패키지 포함하지 않는다.
    - 동일 클래스네임을 갖는 경우 컴파일 에러 발생 → 임포트하지 않고 별도로 사용 해야함.
        - 클래스 전체 이름을 사용해서 어떤 패키지의 클래스인지 체크 필요.

## 6.13 접근 제한자

- 객체의 필드를 외부에서 변경하거나 메소드를 호출할 수 없도록 막아야 할 필요가 있음
- 객체의 무결성을 유지하기 위해서 중요 필드와 메소드를 노출하지 않고자함.
- 캡슐화

### 접근제한제

- 접근 제한을 갖느냐에 따라 호출가능 여부가 결정됨
- `public`: 제한 없음
- `prorected`: 같은 패키지, 자식 객체만 사용
- `(default)`: 같은 패키지
- `private`: 객체 내부

### 클래스의 접근 제한

- 클래스는 `public` || `(default)`만 가진다.
- 사용가능 여부가 결정됨

### 생성자 접근 제한

- `public`: 모든 패키지
- `(default)`: 같은 패키지
- `private`: 클래스 내부

### 필드와 메소드 접근 제한

- `public`: 모든 패키지
- `(default)`: 같은 패키지
- `private`: 클래스 내부

## 6.14 Getter와 Setter

- 객체의 필드를 외부에서 마음대로 읽고 변경할 경우 객체의 무결성이 깨질 수 있음
    - 직접 접근을 막고 메소드를 통해 필드에 접근하는 방식을 선호

```java
//Field
private 타입 fieldName;

//Getter
public 타입 getFieldName(){
	return fieldName;
}
//Setter
public void setFieldName(타입 fieldName){
	this.fieldName = fieldName;
}
```

- Field
    - 필드 접근 제한자: private
- Setter()
    - 접근 제한자: public
    - 리턴 타입: 필드타입
    - 메소드 이름: get + 필드이름(첫 글자 대문자)
    - 리턴값: 필드값
- Getter()
    - 접근 제한자: public
    - 리턴 타입: void
    - 메소드 이름: set + 필드이름(첫 글자 대문자)
    - 매개변수 타입: 필드타입
- 필드 타입이 `boolean` 인경우 is로 시작하는 것이 관례
    - `public boolean isStop(){return stop;}`
    - `true` / `false` 상태 가져오

## 6.15 싱글톤(Singleton) 패턴

- 애플리케이션 전체에서 단 한 개의 객체만 생성해서 사용
- 생성자를 private 접근 제한해 외부에서 new 연산자로 생성자를 호출할 수 없도록 막는 것
- 정적메소드를 통해 간접적으로 객체 얻을 수 있음.

```java
public class 클래스{
	//private 접근 권한을 갖는 정적필드 선언과 초기화
	private static 클래스 singleton = new 클래스(); 
		// 미리 객체를 생성 초기화
		// 외부에서 정적 필드값을 변경하지 못하도록 막는다.

	//private 접근 권한을 갖는 생성자 선언
	private 클래스(){}

	//public 접근 권한을 갖는 정적 메소드 선언
	public static 클래스 getInstance(){
		return singleton;
	}
		// 정적 필드값을 리턴하는 메소드를 퍼블릭으로 선언
		// 외부에서 객체를 얻는 유일한 방법 getInstance 호
}
```